#!/bin/sh
#
# The GPLv2 License
#
#   Copyright (C) 2019 Peter Kenji Yamanaka
#   Copyright (c) 2015 Héctor Molinero Fernández
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along
#   with this program; if not, write to the Free Software Foundation, Inc.,
#   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Author:
#  Héctor Molinero Fernández <hector@molinero.xyz>.
#
# Modified by:
#  pyamsoft <developer(dot)pyamsoft(at)gmail(dot)com>

# Will cause calls to
#
# $ sh update-hosts
#
# to fail.
#
# Prevent the script from being sourced
# if [ "$(basename "$_")" != "update-hosts" ]; then
#   # Return, script was sourced
#   return 0
# fi

##
# Display a general message
##
action_msg()
{
  if [ "$#" -eq 0 ]; then
    return 1
  fi

  action_msg__message="$1"
  shift

  printf -- "%b + %b${action_msg__message}%b\\n" "\\033[1;33m" "\\033[1;32m" \
    "$@" "\\033[0m"

  unset action_msg__message
  return 0
}

##
# Display an error message
##
error_msg()
{
  if [ "$#" -eq 0 ]; then
    return 1
  fi

  error_msg__message="$1"
  shift

  printf -- "%b + %b${error_msg__message}%b\\n" "\\033[1;33m" "\\033[1;31m" \
    "$@" "\\033[0m"

  unset error_msg__message
  return 0
}

##
# Display an information snippet
##
info_msg()
{
  if [ "$#" -eq 0 ]; then
    return 1
  fi

  info_msg__message="$1"
  shift

  # shellcheck disable=SC2059
  printf -- "   - ${info_msg__message}\\n" "$@"

  unset info_msg__message
  return 0
}

##
# Check the environment path for the either wget or curl
# return if it is not found
##
check_for_download_ability()
{
  if ! check_for_binary curl > /dev/null 2>&1; then
    if ! check_for_binary wget > /dev/null 2>&1; then
      printf -- "Either wget or curl are required for this script\\n"
      printf -- "Please install either 'wget' or 'curl' onto your system.\\n"

      return 1
    fi
  fi

  return 0
}

##
# Check the environment path for the given binary, return if it is not found
#
# $1 the binary to check on the PATH
##
check_for_binary()
{
  check_binary__bin="$1"
  if [ -z "${check_binary__bin}" ]; then
    # Can't assume we have printf here
    echo "Must specify a path to a binary"
    unset check_binary__bin
    return 1
  fi

  check_binary__found=0
  check_binary__path="$(echo "${PATH}" | tr ':' ' ')"
  for check_binary__loc in ${check_binary__path}; do
    if [ -x "${check_binary__loc}/${check_binary__bin}" ]; then
      check_binary__found=1
      break
    fi
  done

  if [ "${check_binary__found}" -eq 1 ]; then
    unset check_binary__bin
    unset check_binary__found
    unset check_binary__path
    unset check_binary__loc
    return 0
  else
    # Can't assume we have printf here
    echo "Binary '${check_binary__bin}' not found in \$PATH"
    unset check_binary__bin
    unset check_binary__found
    unset check_binary__path
    unset check_binary__loc
    return 1
  fi
}

##
# Print out the hosts configuration
#
# $1 hosts file location
# $2 hosts destination IP
##
print_hosts_config()
{
  print_hosts_config__file="$1"
  print_hosts_config__ip="$2"

  action_msg "Hosts Configuration:"
  info_msg "Lock file: %s" "${SUDOLOCK}"
  info_msg "Hosts location: %s" "${print_hosts_config__file}"
  info_msg "Destination IP: %s" "${print_hosts_config__ip}"

  unset print_hosts_config__file
  unset print_hosts_config__ip
  return 0
}

##
# Print out the ipset configuration
#
# $1 sudo or blank if not needed
# $2 ipset file location
# $3 ipset name
##
print_ipset_config()
{
  print_ipset_config__sudo="$1"
  print_ipset_config__file="$2"
  print_ipset_config__name="$3"

  action_msg "Ipset Configuration:"
  info_msg "Ipset location: %s" "${print_ipset_config__file}"
  info_msg "Ipset name: %s" "${print_ipset_config__name}"

  # The ipset must exist first for this script to work
  # check for existence here
  ${print_ipset_config__sudo} ipset \
    list "${print_ipset_config__name}" > /dev/null 2>&1 || {
    action_msg "Ipset %s does not exist, creating it" \
      "${print_ipset_config__name}"

    # Make the ipset
    ${print_ipset_config__sudo} ipset create "${print_ipset_config__name}" \
      hash:net maxelem $((128 * 1024))
  }

  unset print_ipset_config__sudo
  unset print_ipset_config__file
  unset print_ipset_config__name
  return 0
}

##
# Decide what program to DL with
#
# Echoes the name of the program to use as an HTTP client for downloading the
# sources
##
decide_dl_client()
{
  # Check for curl, if not found, use wget, as the check for either
  # Should have passed before this function
  decide_dl_client__cmd=

  if check_for_binary curl > /dev/null 2>&1; then
    decide_dl_client__cmd="curl -fsSL -A 'Mozilla/5.0' --connect-timeout 20"
  else
    decide_dl_client__cmd="wget -qO- -U 'Mozilla/5.0' --timeout 20"
  fi

  # Echo before unsetting
  printf -- "%s" "${decide_dl_client__cmd}"

  unset decide_dl_client__cmd
  return 0
}

##
# Process each temporary Ipset source file
#
# $1 temporary file location
# $2 source url
##
process_ipset_sources()
{
  process_ipset_sources__file="$1"
  process_ipset_sources__url="$2"

  change_eol "${process_ipset_sources__file}" \
    "${process_ipset_sources__url}"
  remove_comments "${process_ipset_sources__file}" \
    "${process_ipset_sources__url}"
  trim_whitespace "${process_ipset_sources__file}" \
    "${process_ipset_sources__url}"
  select_ip_lines "${process_ipset_sources__file}" \
    "${process_ipset_sources__url}"

  unset process_ipset_sources__file
  unset process_ipset_sources__url
  return 0
}

##
# Process each temporary hosts source file
#
# $1 temporary file location
# $2 source url
##
process_hosts_sources()
{
  process_hosts_sources__file="$1"
  process_hosts_sources__url="$2"

  change_eol "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  remove_comments "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  trim_whitespace "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  select_host_lines "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  remove_untrusted_domain "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  normalize_to_lowercase "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"
  remove_local_entries "${process_hosts_sources__file}" \
    "${process_hosts_sources__url}"

  unset process_hosts_sources__file
  unset process_hosts_sources__url
  return 0
}

##
# Parse the hosts file together from the various sources
#
# $1 The HTTP client to use
# $2 The URL of the source
# $3 The temporary file location
# $4 The command to run after downloading, begins with process_*
##
download_to_tempfile()
{
  download_to_tempfile__client="$1"
  download_to_tempfile__url="$2"
  download_to_tempfile__file="$3"
  download_to_tempfile__process_hook="$4"
  download_to_tempfile__content=

  info_msg "Downloading from %s" "${download_to_tempfile__url}"
  download_to_tempfile__content="$(printf -- "%s" \
    "$(${download_to_tempfile__client} "${download_to_tempfile__url}")")"
  if [ -z "${download_to_tempfile__content}" ]; then
    error_msg "Failed to download from: %s" "${download_to_tempfile__url}"
    return 1
  fi

  # Guarantee an empty file
  printf -- "%s\\n" "${download_to_tempfile__content}" \
    > "${download_to_tempfile__file}"

  # Run after download processing hook
  "${download_to_tempfile__process_hook}" \
    "${download_to_tempfile__file}" "${download_to_tempfile__url}"

  unset download_to_tempfile__client
  unset download_to_tempfile__process_hook
  unset download_to_tempfile__url
  unset download_to_tempfile__file
  unset download_to_tempfile__content
  return 0
}


##
# Download the source file from each URL specified in source
# Download runs in parallel in the background
#
# $1 The HTTP client to use
# $2 The sources list to download from
# $3 Name of the function to call after download, begins with process_*
##
download_sources()
{
  download_sources__client="$1"
  download_sources__sources="$2"
  download_sources__process_hook="$3"

  # Set the IFS to newlines only
  download_sources__old_ifs="${IFS}"
  IFS="
"
  for download_sources__url in ${download_sources__sources}; do
    # Set the IFS back to normal
    IFS="${download_sources__old_ifs}"

    # Trim spaces and strip comments
    download_sources__url="$(printf -- "%s" "${download_sources__url}" \
      | sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//; s/#.*$//g')"
    if [ -n "${download_sources__url}" ]; then
      case "${download_sources__url}" in
        \#*)
          # Comments are skipped
          continue
          ;;
        *)
          download_sources__tempfile=
          download_sources__tempfile="$(mktemp)"

          # Add the tempfile to list of temporary files
          __temp_files="${download_sources__tempfile} "${__temp_files}

          download_to_tempfile "${download_sources__client}" \
            "${download_sources__url}" "${download_sources__tempfile}" \
            "${download_sources__process_hook}" &

          # Add the pid to list of pids
          __pids="${__pids} $!"

          unset download_sources__tempfile
          unset download_sources__url
          ;;
      esac
    fi

    # Set the IFS back to weird
    IFS="
"
  done

  # Set the IFS back to normal
  IFS="${download_sources__old_ifs}"

  # Wait for all parallel downloads to finish
  # Instead of taking a long time in total, this will only take as long
  # as it takes for the longest download to complete
  #
  # Do not quote so that this will split into a list, instead of a single,
  # space separated input
  # shellcheck disable=SC2086
  wait ${__pids}

  # Write the contents of each download to the blocklist
  for f in ${__temp_files}; do
    download_sources__tempfile_content=

    download_sources__tempfile_content="$(cat "$f")"
    if [ -n "${download_sources__tempfile_content}" ]; then
      if [ -z "${__blocklist}" ]; then
        __blocklist="$(printf -- "%s\\n" \
          "${download_sources__tempfile_content}")"
      else
        __blocklist="$(printf -- "%s\\n%s\\n" \
          "${__blocklist}" "${download_sources__tempfile_content}")"
      fi
    fi

    # Remove the temp file
    rm -f "$f"

    unset f
    unset download_sources__tempfile_content
  done

  unset download_sources__client
  unset download_sources__sources
  unset download_sources__process_hook
  return 0
}

##
# Change EOL from DOS to Unix format
#
# $1 file location
# $2 source url
##
change_eol()
{
  change_eol__file="$1"
  change_eol__url="$2"
  info_msg "Change EOL to Unix format: %s (%s)" "${change_eol__url}" \
    "${change_eol__file}"
  # Use tr instead of GNU sed extension
  change_eol__contents="$(tr -d '\r' < "${change_eol__file}")"
  printf -- "%s\\n" "${change_eol__contents}" > "${change_eol__file}"

  unset change_eol__contents
  unset change_eol__file
  unset change_eol__url
  return 0
}

##
# Remove comments from files
#
# $1 file location
# $2 source url
##
remove_comments()
{
  remove_comments__file="$1"
  remove_comments__url="$2"
  info_msg "Remove any comments from file: %s (%s)" "${remove_comments__url}" \
    "${remove_comments__file}"

  # Removes comments from files
  remove_comments__contents="$(sed 's/#.*$//g' < "${remove_comments__file}")"
  printf -- "%s\\n" "${remove_comments__contents}" > "${remove_comments__file}"

  unset remove_comments__contents
  unset remove_comments__file
  unset remove_comments__url
  return 0
}

##
# Remove whitespace from files
#
# $1 file location
# $2 source url
##
trim_whitespace()
{
  trim_whitespace__file="$1"
  trim_whitespace__url="$2"
  info_msg "Trim whitespace from lines in: %s (%s)" "${trim_whitespace__url}" \
    "${trim_whitespace__file}"

  # Trim whitespace from lines
  trim_whitespace__contents="$(sed 's/[[:blank:]]*$//g; s/^[[:blank:]]*//g' \
    < "${trim_whitespace__file}")"

  # Remove empty lines
  trim_whitespace__contents="$(printf -- "%s" "${trim_whitespace__contents}" \
    | sed '/^$/d')"
  printf -- "%s\\n" "${trim_whitespace__contents}" > "${trim_whitespace__file}"

  unset trim_whitespace__contents
  unset trim_whitespace__file
  unset trim_whitespace__url
  return 0
}

##
# Only select lines which contain a host, do not select comments/other
#
# $1 file location
# $2 source url
##
select_host_lines()
{
  select_host_lines__file="$1"
  select_host_lines__url="$2"


  # KLUDGE
  # This leaves trailing comments in lines, making it not as effective
  # sed -n -i -r "/(^(${ip_regex})|^)${domain_regex}/p" "$1"
  #
  # This is an ugly workaround
  info_msg "Select only hosts lines: %s (%s)" "${select_host_lines__url}" \
    "${select_host_lines__file}"

  # Technically this does not check that the actual digits are valid IP addresses
  # but that is alright because the IP addresses themselves will be replaced
  readonly IP_REGEX='\([[:digit:]]\{1,3\}\.\)\{3\}[[:digit:]]\{1,3\}'
  readonly DOMAIN_REGEX='\([[:alnum:]_-]\{1,63\}\.\)\{1,\}[[:alpha:]][[:alnum:]_-]\{1,62\}'

  # sed -n is POSIX (man 1p sed)
  select_host_lines__content="$(sed -n \
    "/^\\(${IP_REGEX}[[:blank:]]\\{1,\\}\\)\\{0,1\\}${DOMAIN_REGEX}$/p" \
    < "${select_host_lines__file}")"

  # Echo out result
  printf -- "%s" "${select_host_lines__content}" > "${select_host_lines__file}"

  unset select_host_lines__file
  unset select_host_lines__url
  unset select_host_lines__content
  return 0
}

##
# Only select lines which contain an ip, do not select comments/other
#
# $1 file location
# $2 source url
##
select_ip_lines()
{
  select_ip_lines__file="$1"
  select_ip_lines__url="$2"

  info_msg "Select only IP lines: %s (%s)" "${select_ip_lines__url}" "${select_ip_lines__file}"

  # Use awk to emulate grep -oE
  # we pass the regex in as a regex constant so that it is not evaulated wrongly by the shell
  # This regex is long because checks for valid IP addresses only
  select_ip_lines__content="$(awk \
    'match($0, /(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(|\/([0-9]|[1-2][0-9]|3[0-2]))/) {
      print substr($0, RSTART, RLENGTH)
    }' "${select_ip_lines__file}")"

  # Echo out result
  printf -- "%s" "${select_ip_lines__content}" > "${select_ip_lines__file}"

  unset select_ip_lines__content
  unset select_ip_lines__file
  unset select_ip_lines__url
  return 0
}

##
# Remove any predefined destinations, as they may be untrustworthy
#
# $1 file
# $2 url
##
remove_untrusted_domain()
{
  remove_untrusted_domain__file="$1"
  remove_untrusted_domain__url="$2"
  info_msg "Remove old destination: %s (%s)" "${remove_untrusted_domain__url}" \
    "${remove_untrusted_domain__file}"

  # Remove any domain that may be included in the downloaded file
  remove_untrusted_domain__content="$(sed 's/^.\{1,\}[[:blank:]]\{1,\}//g' \
    < "${remove_untrusted_domain__file}")"
  printf -- "%s" "${remove_untrusted_domain__content}" \
    > "${remove_untrusted_domain__file}"

  unset remove_untrusted_domain__content
  unset remove_untrusted_domain__file
  unset remove_untrusted_domain__url
  return 0
}

##
# Normalize all entries to lowercase strings
#
# $1 file
# $2 url
##
normalize_to_lowercase()
{
  normalize_to_lowercase__file="$1"
  normalize_to_lowercase__url="$2"
  info_msg "Transform all entries to lowercase: %s (%s)" \
    "${normalize_to_lowercase__url}" "${normalize_to_lowercase__file}"

  normalize_to_lowercase__content="$(tr '[:upper:]' '[:lower:]' \
    < "${normalize_to_lowercase__file}")"
  printf -- "%s" "${normalize_to_lowercase__content}" \
    > "${normalize_to_lowercase__file}"

  unset normalize_to_lowercase__file
  unset normalize_to_lowercase__url
  unset normalize_to_lowercase__content
  return 0
}

##
# Remove any entries containing the localhost, as it will be added by
# the hosts_header later on
#
# $1 file
# $2 url
##
remove_local_entries()
{
  remove_local_entries__file="$1"
  remove_local_entries__url="$2"

  info_msg "Remove local entries: %s (%s)" "${remove_local_entries__url}" \
    "${remove_local_entries__file}"

  # Remove any lines which include things like localhost, or localhost.localdomain
  readonly LOCAL_DOMAIN_REGEX='/\.\localdomain[[:blank:]]*$/d; /\.\local[[:blank:]]*$/d'

  remove_local_entries__content="$(sed "${LOCAL_DOMAIN_REGEX}" \
    < "${remove_local_entries__file}")"
  printf -- "%s" "${remove_local_entries__content}" \
    > "${remove_local_entries__file}"

  unset remove_local_entries__content
  unset remove_local_entries__file
  unset remove_local_entries__url
  return 0
}

##
# Apply the user hosts_whitelist
#
# $1 whitelist
##
apply_whitelist()
{
  apply_whitelist__whitelist="$1"

  info_msg "Apply whitelist entries"
  if [ -z "${__blocklist}" ]; then
    error_msg "Block list is empty"
    return 1
  fi

  apply_whitelist__old_ifs="${IFS}"

  # Set IFS to newline
  IFS="
"
  for apply_whitelist__domain in ${apply_whitelist__whitelist}; do
    # Set IFS back to normal
    IFS="${apply_whitelist__old_ifs}"

    apply_whitelist__domain="$(printf -- "%s" "${apply_whitelist__domain}" \
      | sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//; s/#.*$//g')"
    if [ -n "${apply_whitelist__domain}" ]; then
      case "${apply_whitelist__domain}" in
        \#*)
          # Skip comments
          continue
          ;;
        *)
          __blocklist="$(printf -- "%s\\n" "${__blocklist}" \
            | sed "/${apply_whitelist__domain}/d")"
          unset apply_whitelist__domain
          ;;
      esac
    fi

    # Set IFS back to newline
    IFS="
"
  done

  # Set IFS back to normal
  IFS="${apply_whitelist__old_ifs}"

  unset apply_whitelist__whitelist
  return 0
}

##
# Apply the user blacklist
#
# $1 blacklist
##
apply_blacklist()
{
  apply_blacklist__blacklist="$1"

  info_msg "Apply blacklist entries"
  # Cache the hosts_blacklist domains so that the entire block list
  # does not have to be echoed each time.
  # Domains initialized as first hosts_blacklist entry
  apply_blacklist__domains=""

  apply_blacklist__old_ifs="${IFS}"

  # Set IFS to newline
  IFS="
"
  for apply_blacklist__domain in ${apply_blacklist__blacklist}; do
    # Set IFS back to normal
    IFS="${apply_blacklist__old_ifs}"

    apply_blacklist__domain="$(printf -- "%s" "${apply_blacklist__domain}" \
      | sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//; s/#.*$//g')"
    if [ -n "${apply_blacklist__domain}" ]; then
      case "${apply_blacklist__domain}" in
        \#*)
          # Skip comments
          continue
          ;;
        *)
          if [ -z "${apply_blacklist__domains}" ]; then
            apply_blacklist__domains="${apply_blacklist__domain}"
          else
            apply_blacklist__domains="$(printf -- "%s\\n%s\\n" \
              "${apply_blacklist__domains}" \
              "${apply_blacklist__domain}")"
          fi
          ;;
      esac
    fi

    # Set IFS to newline
    IFS="
"
  done

  # Set IFS back to normal
  IFS="${apply_blacklist__old_ifs}"

  if [ -z "${__blocklist}" ]; then
    __blocklist="$(printf -- "%s\\n" "${apply_blacklist__domains}")"
  else
    __blocklist="$(printf -- "%s\\n%s\\n" \
      "${__blocklist}" "${apply_blacklist__domains}")"
  fi

  unset apply_blacklist__domains
  unset apply_blacklist__blacklist
  return 0
}

##
# Remove duplicate entries
##
remove_duplicates()
{
  info_msg "Remove duplicate entries"
  __blocklist="$(printf -- "%s\\n" "${__blocklist}" | uniq)"

  return 0
}

##
# Sort the entries by string numerical value
##
sort_entries()
{
  info_msg "Sort entries"
  __blocklist="$(printf -- "%s\\n" "${__blocklist}" | sort)"

  return 0
}

##
# Add the configured destination, by default the zero address
#
# $1 desitination IP address
##
add_new_destination()
{
  add_new_destination__ip="$1"

  info_msg "Add new destination"
  __blocklist="$(printf -- "%s\\n" "${__blocklist}" \
    | sed "s/^/${add_new_destination__ip} /g")"

  unset add_new_destination__ip
  return 0
}

##
# Parse the hosts_header and create the new hosts file
#
# Outputs the completed hosts file contents
#
# $1 additional host headers
##
generate_new_hosts_file()
{
  generate_new_hosts_file__header="${BASE_HOSTS_HEADER}
  $1"

  generate_new_hosts_file__header="$(printf -- \
    "# <hosts_header>%s# </hosts_header>\\n" \
    "$(printf -- '%s' "${generate_new_hosts_file__header}" | uniq)" \
    | sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//;')"

  # Log the hosts sources
  generate_new_hosts_file__sources=""

  # Set the IFS to newlines only
  generate_new_hosts_file__ifs="${IFS}"
  IFS="
"
  for hosts_source in ${HOSTS_SOURCES}; do

    # Set back to normal IFS
    IFS="${generate_new_hosts_file__ifs}"

    # Trim spaces and strip comments
    hosts_source="$(printf -- "%s" "${hosts_source}" \
      | sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//; s/#.*$//g')"
    if [ -n "${hosts_source}" ]; then
      case "${hosts_source}" in
        \#*)
          # Comments are skipped
          continue
          ;;
        *)
          if [ -z "${generate_new_hosts_file__sources}" ]; then
            generate_new_hosts_file__sources="# ${hosts_source}"
          else
            generate_new_hosts_file__sources="# ${hosts_source}
${generate_new_hosts_file__sources}"
          fi
          ;;
      esac
    fi

    # Set IFS back
    IFS="
"
    unset hosts_source
  done

  # Leave a note
  generate_new_hosts_file__sources="# File is generated from the following sources:
${generate_new_hosts_file__sources}"

  generate_new_hosts_file__header="$(printf -- "# %s\\n%s\\n%s\\n" \
    "$(date)" \
    "${generate_new_hosts_file__sources}" \
    "${generate_new_hosts_file__header}")"

  printf -- "%s\\n# <blocklist>\\n%s\\n# </blocklist>" \
    "${generate_new_hosts_file__header}" \
    "${__blocklist}"

  unset generate_new_hosts_file__sources
  unset generate_new_hosts_file__header
  unset __blocklist
  return 0
}

##
# Backup original file
#
# $1 needs_sudo
# $2 file name
# $3 backup name
##
backup_old_file()
{
  backup_old_file__sudo="$1"
  backup_old_file__file="$2"
  backup_old_file__backup="$3"

  if [ -f "${backup_old_file__file}" ]; then
    info_msg "Creating backup of original file %s ..." \
      "${backup_old_file__file}"
    ${backup_old_file__sudo} cp \
      "${backup_old_file__file}" "${backup_old_file__backup}" || {
      error_msg "Failed to copy to file %s" "${backup_old_file__backup}"

      unset backup_old_file__sudo
      unset backup_old_file__file
      unset backup_old_file__backup
      return 1
    }
  else
    info_msg "No original file exists to create backup"
  fi

  unset backup_old_file__sudo
  unset backup_old_file__file
  unset backup_old_file__backup
  return 0
}

##
# Install the new hosts file to the destination
#
# $1 needs_sudo
# $2 hosts file content
# $3 file destination location
##
install_new_hosts_file()
{
  install_new_hosts_file__sudo="$1"
  install_new_hosts_file__hosts="$2"
  install_new_hosts_file__destination="$3"

  info_msg "Installing new hosts file %s..." \
    "${install_new_hosts_file__destination}"
  printf -- "%s\\n" "${install_new_hosts_file__hosts}" \
    | ${install_new_hosts_file__sudo} tee \
    "${install_new_hosts_file__destination}" > /dev/null \
    || {
    error_msg "Failed to output to file %s" \
      "${install_new_hosts_file__destination}"

    unset install_new_hosts_file__sudo
    unset install_new_hosts_file__hosts
    unset install_new_hosts_file__destination
    return 1
  }

  unset install_new_hosts_file__sudo
  unset install_new_hosts_file__hosts
  unset install_new_hosts_file__destination
  return 0
}

##
# Installs the ipset into the file given and then commits to the
# named ipset
#
# $1 needs_sudo
# $2 ipset detination file
# $3 ipset name
install_ipset_blocklist()
{
  install_ipset_blocklist__sudo="$1"
  install_ipset_blocklist__file="$2"
  install_ipset_blocklist__name="$3"

  action_msg "Install the ipset blocklist"
  info_msg "Clear existing block list"
  printf -- "" \
    | ${install_ipset_blocklist__sudo} \
    tee "${install_ipset_blocklist__file}" > /dev/null
  ${install_ipset_blocklist__sudo} ipset \
    flush "${install_ipset_blocklist__name}"

  info_msg "Create new blocklist"
  # Save here just to get the create line
  ${install_ipset_blocklist__sudo} ipset save \
    "${install_ipset_blocklist__name}" \
    | ${install_ipset_blocklist__sudo} tee \
      "${install_ipset_blocklist__file}" > /dev/null

  # Because we have a bunch of /32 addresses, we attempt to reduce the
  # size of the list by merging all the ones we can into different subnets
  check_for_binary iprange > /dev/null 2>&1 && {
    # If we have the iprange binary, run an optimization on the set
    info_msg "Optimize ipset using iprange to reduce entry count"

    # Take count of the entries before and after
    old_count="$(printf -- "%s" "${__blocklist}" | wc -l)"
    __blocklist=$(printf -- "%s" "${__blocklist}" | iprange --ipset-reduce-entries 1)
    new_count="$(printf -- "%s" "${__blocklist}" | wc -l)"

    info_msg "Old count: ${old_count}"
    info_msg "New count: ${new_count}"
    unset old_count
    unset new_count
  }

  info_msg "Add new IPs to the block list"
  __blocklist=$(printf -- "%s\\n" "${__blocklist}" | sed 's/^/add blocklist /')
  printf -- "%s\\n" "${__blocklist}" \
    | ${install_ipset_blocklist__sudo} tee \
    -a "${install_ipset_blocklist__file}" > /dev/null \
    || {
    error_msg "Failed to add ipset to blocklist"

    unset install_ipset_blocklist__sudo
    unset install_ipset_blocklist__file
    unset install_ipset_blocklist__name
    return 1
  }

  info_msg "Commit new ipset"
  ${install_ipset_blocklist__sudo} ipset restore \
    -exist -file "${install_ipset_blocklist__file}"

  unset install_ipset_blocklist__sudo
  unset install_ipset_blocklist__file
  unset install_ipset_blocklist__name
  return 0
}


##
# Fixes permission on file to 644
#
# $1 needs_sudo
# $2 file to fix
##
fix_file_permissons()
{
  fix_file_permissons__sudo="$1"
  fix_file_permissons__file="$2"

  if [ -f "${fix_file_permissons__file}" ]; then
    info_msg "Fixing permissions for file %s..." "${fix_file_permissons__file}"
    ${fix_file_permissons__sudo} chmod 644 "${fix_file_permissons__file}" \
      || {
      error_msg "Failed to chmod %s to 644" "${fix_file_permissons__file}"

      unset fix_file_permissons__sudo
      unset fix_file_permissons__file
      return 1
    }
  else
    info_msg "Cannot fix permission for non-existant file %s" \
      "${fix_file_permissons__file}"
  fi

  unset fix_file_permissons__sudo
  unset fix_file_permissons__file
  return 0
}

##
# Create a backup file name by appending the current date
# $1 file name
create_backup_name()
{
  create_backup_name__file="$1"

  # Echo out file name
  printf -- "%s.backup.%s" "${create_backup_name__file}" "$(date +%Y%m%d)"

  unset create_backup_name__file
  return 0
}

##
# Print the differences between the number of lines in each file
#
# $1 new file
# $2 old file
##
print_file_differences()
{
  print_file_differences__new="$1"
  print_file_differences__old="$2"

  print_file_differences__old_n=0
  if [ -f "${print_file_differences__old}" ]; then
    print_file_differences__old_n=$(wc -l < "${print_file_differences__old}")
  fi

  print_file_differences__new_n=
  print_file_differences__new_n=$(wc -l < "${print_file_differences__new}")

  # Echo out the result
  print_file_differences__diff=$((print_file_differences__new_n - print_file_differences__old_n))
  printf -- "%b + %b%s %bentries added! (%b + %b%s %b)\\n" \
    "\\033[1;33m" "\\033[1;32m" "${print_file_differences__new_n}" \
    "\\033[0m" "\\033[1;32m" "\\033[1;34m" "${print_file_differences__diff}" \
    "\\033[0m"

  unset print_file_differences__diff
  unset print_file_differences__old
  unset print_file_differences__new
  unset print_file_differences__old_n
  unset print_file_differences__new_n
  return 0
}

##
# Remove all backup files that start with the given pattern
#
# $1 needs_sudo
# $2 normal file name
remove_all_backup_files()
{
  remove_all_backup_files__sudo="$1"
  remove_all_backup_files__file="$2"
  for remove_all_backup_files__temp in \
    "${remove_all_backup_files__file}".backup.*; do
    remove_all_backup_files__temp="$(printf -- "%s" \
      "${remove_all_backup_files__temp}" \
      | sed 's/^[[:blank:]]*//' | sed 's/[[:blank:]]*$//')"
    if [ -n "${remove_all_backup_files__temp}" ]; then
      info_msg "Removing backup file: %s..." "${remove_all_backup_files__temp}"
      ${remove_all_backup_files__sudo} rm -f \
        "${remove_all_backup_files__temp}" > /dev/null 2>&1
      unset remove_all_backup_files__temp
    fi
  done

  unset remove_all_backup_files__sudo
  unset remove_all_backup_files__file
  return 0
}

##
# While the script is running, continue to refresh sudo timer
# This should be run in the background
sudoloop()
{
  touch "${SUDOLOCK}"
  while [ -e "${SUDOLOCK}" ]; do
    sudo -n -v
    sleep 2
  done

  return 0
}

##
# Clean up any temp files and kill any processes that are still running
# Also clears any global variables that are used
cleanup()
{
  # Kill runaway pids
  for p in ${__pids}; do
    p="$(printf -- "%s" "${p}" \
      | sed 's/^[[:blank:]]*//' | sed 's/[[:blank:]]*$//')"
    if [ -n "${p}" ]; then
      kill "${p}" > /dev/null 2>&1
    fi
  done

  # rm leftover files
  for temp in ${__temp_files}; do
    temp="$(printf -- "%s" "${temp}" \
      | sed 's/^[[:blank:]]*//' | sed 's/[[:blank:]]*$//')"
    if [ -n "${temp}" ]; then
      rm -f "${temp}" > /dev/null 2>&1
    fi
  done

  unset __blocklist
  __blocklist=""

  unset __pids
  __pids=""

  unset __temp_files
  __temp_files=""

  return 0
}

##
# Cancels the sudoloop if it is running
# performs cleanup and then exits the script
cancel_sudoloop()
{
  [ -e "${SUDOLOCK}" ] && rm -f "${SUDOLOCK}"
  cleanup

  # Exit point

  # Did we pass in an exit code or no?
  if [ "$#" -lt 1 ] || [ -z "$1" ]; then
    exit 1
  else
    exit "$1"
  fi
}

##
# Echoes out the current version held by the constant __VERSION
print_version()
{
  printf -- "update-hosts[%s]\\n" "${__VERSION}"
  echo

  return 0
}

##
# Print out help
print_help()
{
  print_version
  printf -- "%s\\n" "$(cat << EOF
Options:
   -h | --help     Display help
   -v | --version  Display version
   -r | --remove   Remove backups
   -i | --ipset    Also download ipset sources
   -u | --unbreak  Auto apply the unbreak whitelist
   --source        Source a hosts file part
   --output-hosts  The file to output hosts to
   --output-ipset  The file to output ipsets to
   --ipset-name    The name of the ipset
   --dest-ip       The destination IP to use
EOF
)"
  return 0
}

##
# Main function which handles the downloading of hosts files
#
# $1 needs_sudo
# $2 hosts file destination
# $3 destination IP address
# $4 remove backups
# $5 extra headers
main_hosts()
{
  main_hosts__sudo="$1"
  main_hosts__file="$2"
  main_hosts__ip="$3"
  main_hosts__remove_backup="$4"
  main_hosts__extra_headers="$5"

  # Configuration
  print_hosts_config "${main_hosts__file}" "${main_hosts__ip}"

  # Download
  action_msg "Downloading hosts_sources lists..."
  download_sources "$(decide_dl_client)" \
    "${HOSTS_SOURCES}" "process_hosts_sources" || return 1

  # Parse
  action_msg "Generating hosts file..."
  apply_blacklist "${HOSTS_BLACKLIST}" || return 1
  apply_whitelist "${HOSTS_WHITELIST}" || return 1
  sort_entries || return 1
  remove_duplicates || return 1
  add_new_destination "${main_hosts__ip}" || return 1

  # Install

  info_msg "Create new hosts file"
  hosts="$(generate_new_hosts_file "${main_hosts__extra_headers}")" || return 1
  main_hosts__file_backup="$(create_backup_name \
    "${main_hosts__file}")" || return 1
  backup_old_file "${main_hosts__sudo}" \
    "${main_hosts__file}" "${main_hosts__file_backup}" || return 1
  install_new_hosts_file "${main_hosts__sudo}" \
    "${hosts}" "${main_hosts__file}" || return 1
  fix_file_permissons "${main_hosts__sudo}" \
    "${main_hosts__file}" || return 1
  fix_file_permissons "${main_hosts__sudo}" \
    "${main_hosts__file_backup}" || return 1
  print_file_differences "${main_hosts__file}" \
    "${main_hosts__file_backup}" || return 1

  # Cleanup
  if [ "${main_hosts__remove_backup}" -eq 1 ]; then
    remove_all_backup_files "${main_hosts__sudo}" \
      "${main_hosts__file}" || return 1
  fi

  unset hosts
  unset main_hosts__sudo
  unset main_hosts__file
  unset main_hosts__file_backup
  unset main_hosts__ip
  unset main_hosts__remove_backup
  return 0
}

##
# Main function which handles the downloading of ipset files
#
# $1 needs_sudo
# $2 ipset file destination
# $3 ipset name
# $4 remove backups
main_ipsets()
{
  main_ipsets__sudo="$1"
  main_ipsets__file="$2"
  main_ipsets__name="$3"
  main_ipsets__remove_backup="$4"

  if [ -z "${main_ipsets__sudo}" ] && [ "$(id -u)" -ne 0 ]; then
    error_msg "ipset functionality requires root user privileges"
    return 1
  fi

  # Begin
  printf -- "\\n\\n"
  print_ipset_config "${main_ipsets__sudo}" \
    "${main_ipsets__file}" "${main_ipsets__name}" || return 1

  # Download
  action_msg "Downloading ipset_sources lists..."
  download_sources "$(decide_dl_client)" \
    "${IPSET_SOURCES}" "process_ipset_sources" || return 1

  # Parse
  action_msg "Generating ipset..."
  apply_blacklist "${IPSET_BLACKLIST}" || return 1
  apply_whitelist "${IPSET_WHITELIST}" || return 1
  sort_entries || return 1
  remove_duplicates || return 1

  # Install
  main_ipsets__file_backup=$(create_backup_name \
    "${main_ipsets__file}" ) || return 1
  backup_old_file "${main_ipsets__sudo}" \
    "${main_ipsets__file}" "${main_ipsets__file_backup}" || return 1
  install_ipset_blocklist "${main_ipsets__sudo}" \
    "${main_ipsets__file}" "${main_ipsets__name}" || return 1
  fix_file_permissons "${main_ipsets__sudo}" \
    "${main_ipsets__file}" || return 1
  fix_file_permissons "${main_ipsets__sudo}" \
    "${main_ipsets__file_backup}" || return 1
  print_file_differences "${main_ipsets__file}" \
    "${main_ipsets__file_backup}" || return 1

  # Cleanup
  if [ "${main_ipsets__remove_backup}" -eq 1 ]; then
    remove_all_backup_files "${main_ipsets__sudo}" \
      "${main_ipsets__file}" || return 1
  fi

  unset main_ipsets__sudo
  unset main_ipsets__file
  unset main_ipsets__name
  unset main_ipsets__file_backup
  unset main_ipsets__remove_backup
  return 0
}

##
# Prompts the user for sudo access so that we don't have to ask
# again in case operations take a long time
grab_sudo()
{
  check_for_binary sudo || return 1

  # initialize sudo
  sudo -v || return 1

  # Start sudoloop
  sudoloop &

  return 0
}

main()
{

  # Options
  remove_backups=0
  manage_ipsets=0
  apply_unbreak=0
  extra_headers=""

  # Script begins here
  dst_hosts="/etc/hosts"
  dst_ipset="/etc/ipset.conf"
  ipset_name="blocklist"
  dst_ip="0.0.0.0"

  # Check for required binaries, return out if they are not present
  check_for_download_ability || return 1
  check_for_binary sed || return 1
  check_for_binary sort || return 1
  check_for_binary uniq || return 1
  check_for_binary touch || return 1
  check_for_binary sleep || return 1
  check_for_binary rm || return 1
  check_for_binary tee || return 1
  check_for_binary date || return 1
  check_for_binary tr || return 1
  check_for_binary cp || return 1
  check_for_binary wc || return 1
  check_for_binary printf || return 1
  check_for_binary chmod || return 1
  check_for_binary cat || return 1
  check_for_binary awk || return 1

  # Handle options
  # Options
  #   -h | --help     Display help
  #   -v | --version  Display version
  #   -r | --remove   Remove backups
  #   -i | --ipset    Also download ipset sources
  #   -u | --unbreak  Auto apply the Unbreak whitelist
  #   --source        Source a hosts file part
  #   --output-hosts  The file to output hosts to
  #   --output-ipset  The file to output ipsets to
  #   --ipset-name    The name of the ipset
  #   --dest-ip       The destination IP to use
  #
  # While risky to call eval, this is one way to
  # emulate the bash indirect_expansion ability
  if [ $# -gt 0 ]; then
    long_option=""
    optind_expanded=
    eval optind_expanded="\$${OPTIND}"
    while [ -n "${optind_expanded}" ]; do
      while getopts ":hvriu-:" option; do
        # Set only on long option with arg
        if [ -n "${long_option}" ]; then
          error_msg "Long option --%s expects argument" "${long_option}"
          return 1
        fi

        long_option=""
        case "${option}" in
          -)
            case "${OPTARG}" in
              help)
                print_help
                return 0
                ;;
              version)
                print_version
                return 0
                ;;
              remove)
                remove_backups=1
                ;;
              ipset)
                manage_ipsets=1
                ;;
              unbreak)
                apply_unbreak=1
                ;;
              output-hosts|output-ipset|ipset-name|dest-ip|source)
                long_option="${OPTARG}"
                ;;
              *)
                # We must provide our own error message in this case
                error_msg "Illegal option --%s" "${OPTARG}"
                print_help
                return 1
                ;;
            esac
            ;;
          h)
            print_help
            return 0
            ;;
          v)
            print_version
            return 0
            ;;
          r)
            remove_backups=1
            ;;
          i)
            manage_ipsets=1
            ;;
          u)
            apply_unbreak=1
            ;;
          *)
            error_msg "Illegal option -%s" "${OPTARG}"
            print_help
            return 1
            ;;
        esac
      done

      # Re-establish the current OPTIND target
      if [ $# -ge ${OPTIND} ]; then
        eval optind_expanded="\$${OPTIND}"
      else
        optind_expanded=""
      fi

      # Long option has argument
      if [ -z "${optind_expanded}" ]; then
        if [ -n "${long_option}" ]; then
          error_msg "Long option --%s expects argument" "${long_option}"
          return 1
        else
          break
        fi
      else
        # This is a plain arg and should be handled by one of
        # the options which takes an argument
        case "${long_option}" in
          output-hosts)
            dst_hosts="${optind_expanded}"
            ;;
          output-ipset)
            dst_ipset="${optind_expanded}"
            ;;
          dest-ip)
            dst_ip="${optind_expanded}"
            ;;
          ipset-name)
            ipset_name="${optind_expanded}"
            ;;
          source)
            # We must be able to source from a file that exists and is readable.
            case "${optind_expanded}" in
              http*)
                # Its a network source from somewhere, add it to the HOSTS_SOURCES
                HOSTS_SOURCES="${optind_expanded}
                ${HOSTS_SOURCES}"
                ;;
              *)
                # Else its a file path I hope
                if [ -e "${optind_expanded}" ] && [ -r "${optind_expanded}" ]; then
                  info_msg "Sourcing extra hosts from: %s" "${optind_expanded}"
                  # Trim whitespace off of hosts file
                  extra_headers="# Extra hosts from '${optind_expanded}'
                  $(sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//;' "${optind_expanded}" | uniq)

                  ${extra_headers}"
                else
                  error_msg "Hosts source does not exist: %s" "${optind_expanded}"
                fi
                ;;
            esac
        esac
      fi

      # Set back to null
      long_option=

      option_shift_count="${OPTIND}"
      while [ "$#" -lt "${option_shift_count}" ]; do
        option_shift_count=$((option_shift_count - 1))
      done

      # Need this here incase the loop doesn't run
      if [ "$#" -ge "${option_shift_count}" ]; then
        # Shift the options
        shift ${option_shift_count}
        OPTIND=1
      fi

      # Unset
      unset option_shift_count
    done
  fi

  # Trap return signals
  trap cancel_sudoloop INT TERM

  needs_sudo=
  # If we are not root
  if [ "$(id -u)" -ne 0 ]; then
    if touch "${dst_hosts}" > /dev/null 2>&1; then
      # If we can write to the destination, we don't need sudo
      needs_sudo=""
    else
      action_msg "sudo is needed to write to file: %s" "${dst_hosts}"
      grab_sudo || return 1
      needs_sudo="sudo"
    fi
  else
    error_msg "You cannot run update-hosts as root. Please run as a normal user."
    return 1
  fi


  # Main process
  if [ "${apply_unbreak}" -eq 1 ]; then
    # Dynamically apply the unreak whitelist
    action_msg "You are applying the Unbreak whitelist!"
    info_msg "While this may fix many broken websites, it may also pose"
    info_msg "a potential privacy or security risk. Use at your own discretion"
    HOSTS_WHITELIST="
    ${UNBREAK_WHITELIST}
    ${HOSTS_WHITELIST}
    "
  fi

  # Source extra hosts from default user location
  # Trim whitespace off of hosts file
  readonly user_hosts="${HOME}/.update-hosts"
  if [ -e "${user_hosts}" ] && [ -r "${user_hosts}" ]; then
    info_msg "Source extra hosts from user default location: %s" "${user_hosts}"
    extra_headers="# Extra hosts from '${user_hosts}'
    $(sed 's/^[[:blank:]]*//; s/[[:blank:]]*$//;' "${user_hosts}" | uniq)

    ${extra_headers}"
  fi

  # Parse hosts files
  main_hosts "${needs_sudo}" "${dst_hosts}" \
    "${dst_ip}" "${remove_backups}" "${extra_headers}" || return 1

  if [ "${manage_ipsets}" -eq 0 ]; then
    # End here
    return 0
  fi

  # Start fresh
  cleanup

  # At this point, we do need sudo for ipset operations.
  # Grab it only if we do not already have it
  if [ -z "${needs_sudo}" ]; then
    action_msg "sudo is needed for ipset operations..."
    grab_sudo || return 1
    needs_sudo="sudo"
  fi

  check_for_binary ipset || return 1
  main_ipsets "${needs_sudo}" "${dst_ipset}" \
    "${ipset_name}" "${remove_backups}" || return 1
}

# For more information about these particular options, see
#    https://stackoverflow.com/questions/13468481/when-to-use-set-e
set -u

# dash does not understand pipefail
#
# set -o pipefail

# Export the LC as the default C so that we do not run into locale based quirks
LC_ALL=C
export LC_ALL

# Configuration:

# Version
readonly __VERSION="2.6.6"

check_for_binary mktemp || exit 1
readonly SUDOLOCK="$(mktemp)"

# NOTE: Adding the alias of the 0 domain to itself fixes a display issue that
#       can occur when using traceroute, netstat and the like.
#
# NOTE: This header will be directly inserted into the generated hosts file.
#       We intentionally leave the spacing as is.
#
# Do some additional checking in case the hostname is localhost so we
# do not include it twice
machine_hostname=""
if check_for_binary hostname; then
  machine_hostname="$(hostname)"
  if [ "${machine_hostname}" != "localhost" ]; then
    machine_hostname="${machine_hostname} localhost"
  fi
else
  machine_hostname="localhost"
fi

readonly BASE_HOSTS_HEADER="
# Generated by update-hosts [${__VERSION}]
127.0.0.1 ${machine_hostname}
255.255.255.255 broadcasthost
# Fixes a display anomaly in traceroute and netstat
0.0.0.0 0.0.0.0
"
unset machine_hostname

# The base hosts_sources
# Provides a basic amount of protection without breaking sites, or breaking
# only a minimal amount of sites
readonly BASE_HOSTS_SOURCES='
  https://someonewhocares.org/hosts/hosts
  https://mirror1.malwaredomains.com/files/immortal_domains.txt
  https://adaway.org/hosts.txt
  https://hosts-file.net/ad_servers.txt
  https://pgl.yoyo.org/adservers/serverlist.php?hostformat=hosts&mimetype=plaintext
  https://pgl.yoyo.org/adservers/admiral-domains.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_malvertising.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_malware.txt
  https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt
  https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts
  https://gitlab.com/ZeroDot1/CoinBlockerLists/raw/master/hosts
'

# Additional hosts file servers
readonly additonal_hosts_sources='
  # Very aggressive blocking, sometimes false positive
  #
  # https://ransomwaretracker.abuse.ch/downloads/RW_DOMBL.txt
  # https://zeustracker.abuse.ch/blocklist.php?download=domainblocklist
  # https://raw.githubusercontent.com/EnergizedProtection/block/master/basic/formats/hosts
  # https://raw.githubusercontent.com/jerryn70/GoodbyeAds/master/Hosts/GoodbyeAds.txt

  # Additional Coin blocker lists:
  #
  # https://zerodot1.gitlab.io/CoinBlockerLists/hosts_browser
  # https://zerodot1.gitlab.io/CoinBlockerLists/hosts_optional

  # Hosts-file.net server classifications
  # Provides more in-depth protection and host blocking at the cost of
  # breaking some sites
  #
  # https://hosts-file.net/emd.txt
  # https://hosts-file.net/exp.txt
  # https://hosts-file.net/fsa.txt
  # https://hosts-file.net/hjk.txt
  # https://hosts-file.net/mmt.txt
  # https://hosts-file.net/psh.txt

  # These entries are very large, and may break certain sites
  # that rely on CDNs or third party hosts_sources
  # Instead of downloading the entire hosts file and additional parts
  # the split download above is recommended. The parts that you do not
  # desire can be ignored individually instead of an all or nothing approach.
  # The two hosts_sources below are generally not recommended nor needed. If you
  # wish to use them, be sure to comment out the above hosts-file.net entries
  # or you will largely be pulling duplicate hosts_sources.
  #
  # http://hosts-file.net/download/hosts.txt
  # http://hosts-file.net/hphosts-partial.txt

  # HTTP Sources
  # http://winhelp2002.mvps.org/hosts.txt
  # http://malwaredomains.lehigh.edu/files/justdomains
'



# The hosts_sources that will be parsed into the hosts file.
# By default only the hosts_sources in the ${BASE_HOSTS_SOURCES} list
# are included, additional hosts_sources can be included by
# appending them onto lines following the base-hosts_sources line.
# Destinations and duplicate entries do not matter, as they will
# be sanitized and duplicates will be stripped out.
HOSTS_SOURCES="
  ${BASE_HOSTS_SOURCES}
"

# Regex allowed
#  '\.com$'   -> all domains that end with '.com'
#  '^example' -> all domains that start with 'example'
#  '^sub.\example\.org$' -> literal domain 'sub.exmaple.org'

# Due to the binary yes or no nature of hosts file, all of the domains that
# relate in some way to the uBlock0 Unbreak list will be added here.
# This is to allow uBlock0 to block the specific parts of the domains, while
# not breaking other sites that actually rely on them
# Though not a great solution, this seems to be the only way to get around
# some sites breaking when blocking certain hosts
#
# Because we cannot guarantee that the domains shipped in the whitelist
# are the full domain names, we do not qualify them with '^'
#
# Update 2016/10/15
readonly UNBREAK_WHITELIST='
  google-analytics\.com$
  analytics\.google\.com$
  adf\.ly$
  widget-cdn\.rpxnow\.com$
  tags\.tiqcdn\.com$
  statcounter\.com$
  cdn-static\.liverail\.com$
  vox-static\.liverail\.com$
  s0\.2mdn\.net$
  cdn-i\.dmdentertainment\.com$
  cdn\.vurb\.com$
  target\.122\.2o7\.net$
  adm\.fwmrm\.net$
  mopub\.com$
  safelinking\.net$
  outbrain\.com$
  inc\.com$
  flurry\.com$
  c\.speedtest\.net$
  boldchat\.com$
  mixpanel\.com$
  charlie\.strim.io$
  ovh\.strim.io$
  dn\.turner\.com$
  yui\.yahooapis\.com$
  top\.mail\.ru$
  css\.washingtonpost\.com$
  pcekspert\.com$
  clickbank\.com$
  yandex\.ru$
  yastatic\.net$
  carbonads\.net$
  imasdk\.googleapis\.com$
  2o7\.net$
  quantcast\.com$
  css5\.gaanacdn\.com$
  keen\.github\.io$
  cdn\.phoenix\.intergi\.com$
  kissmetrics\.com$
  viewpoint\.com$
  woopra\.com$
  monetate\.net$
  googleads\.g\.doubleclick\.net$
  img\.echohosting\.cafe24\.com$
  googletagmanager\.com$
  partner\.googleadservices\.com$
  pagefair\.com$
  ssl\.cdn-redfin\.com$
  www\.southwest\.com$
  marketwatch\.com$
  cloudfront\.net$
  nationalreview\.com$
  liveperson\.net$
  taboola\.com$
  ticketmaster\.122\.2o7\.net$
  phoronix\.com$
  files\.explosm\.net$
  cdn\.segment\.com$
  sorted\.org$
  analytics\.edgekey\.net$
  tfag\.de$
  ^nav\.files\.bbci\.co\.uk$
  gamespot\.com$
  umbro\.com$
  shop\.puppetlabs\.com$
  flightradar24\.com$
  premium\.soundcloud\.com$
  stats\.bbc\.co\.uk$
  snoobi\.com$
  esellerate\.net$
  dw\.cbsi\.com$
  data\.netscope\.marktest\.pt$
  gapt.\hit\.gemius\.pl$
  naiadsystems\.com$
  static\.adf\.ly$
  emarketer\.com$
  tapad\.com$
  staticxx\.facebook\.com$
  sp\.computershopper\.com$
  localytics\.com$
  p\.jwpcdn\.com$
  media2\.intoday\.in$
  styletagassets\.com$
  outlook\.live\.com$
  uim\.tifbs\.net$
'

# User defined whitelist
readonly USER_WHITELIST='
'

# Add any of your own custom whitelist modifications to the USER_WHITELIST
# variable
#
# As of version 2.2.0, unbreak list is not added by default
# ${UNBREAK_WHITELIST}
HOSTS_WHITELIST="
  ${USER_WHITELIST}
"

# Only exact strings, no regex supported
readonly ADVERTISEMENT_BLACKLIST='
  # CSGO Advertisements on pinion.gg
  adback.pinion.gg
  api.pinion.gg
  bin.pinion.gg
  blog.pinion.gg
  bork.pinion.gg
  calendar.pinion.gg
  cdn.pinion.gg
  cp.pinion.gg
  crm.pinion.gg
  delivery.pinion.gg
  direct.pinion.gg
  docs.pinion.gg
  immuniser.pinion.gg
  kermit.pinion.gg
  legacy.pinion.gg
  log.pinion.gg
  mail.pinion.gg
  mailer.pinion.gg
  motd.pinion.gg
  ns1.pinion.gg
  ns2.pinion.gg
  ns3.pinion.gg
  ns4.pinion.gg
  ns5.pinion.gg
  ns6.pinion.gg
  office.pinion.gg
  oscar.pinion.gg
  pinion-log.pinion.gg
  pinion.gg
  pog.pinion.gg
  quartermaster.pinion.gg
  seen.pinion.gg
  stage.pinion.gg
  templ4d2.pinion.gg
  tix.pinion.gg
  transcoded.pinion.gg
  video.pinion.gg
  voip.pinion.gg
  wiki.pinion.gg
  www.pinion.gg

  # Spotify advertisements
  media-match.com
  adclick.g.doublecklick.net
  www.googleadservices.com
  open.spotify.com
  pagead2.googlesyndication.com
  desktop.spotify.com
  googleads.g.doubleclick.net
  pubads.g.doubleclick.net
  audio2.spotify.com
  www.omaze.com
  omaze.com
  bounceexchange.com
  pagead46.l.doubleclick.net
  pagead.l.doubleclick.net
  googlehosted.l.googleusercontent.com
  video-ad-stats.googlesyndication.com
  pagead-googlehosted.l.google.com
  partnerad.l.doubleclick.net
  prod.spotify.map.fastlylb.net
  adserver.adtechus.com
  na.gmtdmp.com
  anycast.pixel.adsafeprotected.com
  d361oi6ppvq2ym.cloudfront.net
  gads.pubmatic.com
  idsync-ext.rlcdn.com
  anycast.pixel.adsafeprotected.com
  ads-west-colo.adsymptotic.com
  geo3.ggpht.com
  showads33000.pubmatic.com

  # More Spotify Ads
  media-match.com
  adclick.g.doublecklick.net
  www.googleadservices.com
  open.spotify.com
  pagead2.googlesyndication.com
  desktop.spotify.com
  googleads.g.doubleclick.net
  pubads.g.doubleclick.net
  securepubads.g.doubleclick.net
  audio2.spotify.com
  audio2.spotify.com
  www.audio2.spotify.com
  www.omaze.com
  omaze.com
  bounceexchange.com
  core.insightexpressai.com
  content.bitsontherun.com
  s0.2mdn.net
  v.jwpcdn.com
  d2gi7ultltnc2u.cloudfront.net
  crashdump.spotify.com
  adeventtracker.spotify.com
  log.spotify.com
  analytics.spotify.com
  ads-fa.spotify.com
  cs283.wpc.teliasoneracdn.net
  audio-ec.spotify.com
  cs126.wpc.teliasoneracdn.net
  heads-ec.spotify.com
  u.scdn.co
  cs126.wpc.edgecastcdn.net
  pagead46.l.doubleclick.net
  pagead.l.doubleclick.net
  video-ad-stats.googlesyndication.com
  pagead-googlehosted.l.google.com
  partnerad.l.doubleclick.net
  prod.spotify.map.fastlylb.net
  adserver.adtechus.com
  na.gmtdmp.com
  anycast.pixel.adsafeprotected.com
  ads.pubmatic.com
  idsync-ext.rlcdn.com
  www.googletagservices.com
  sto3.spotify.com
  spclient.wg.spotify.com
  d361oi6ppvq2ym.cloudfront.net
  gads.pubmatic.com
  ads-west-colo.adsymptotic.com
  geo3.ggpht.com
  showads33000.pubmatic.com
  spclient.wg.spotify.com
'

# Jump scare websites
# Only exact strings, no regex supported
readonly JUMPSCARE_BLACKLIST='
  # Jumpscare
  agor.io
  www.agor.io
'

# Any websites that may be deemed unsafe for various reasons
# Things like phishing, malvertising, malware and so forth
readonly BAD_SITE_BLACKLIST='
  com.com
  01net.com
  chip.de
  download.cnet.com
  sourceforge.net
  softonic.com
  flexytalk.net
  quickdomainfwd.com
'

# Block tracking from cliqz domains
readonly TRACKING_BLACKLIST='
  cliqz.com
  www.cliqz.com
  abtests.cliqz.com
  analytics.cliqz.com
  anolysis-gid.cliqz.com
  anti-tracking.cliqz.com
  antiphishing.cliqz.com
  api.cliqz.com
  apisecure.cliqz.com
  beta.cliqz.com
  bookmarks.cliqz.com
  cdn.cliqz.com
  cdn2.cliqz.com
  cdnlogos.cliqz.com
  collector-proxy-network.cliqz.com
  css.cliqz.com
  downloads.cliqz.com
  fbapp.cliqz.com
  fec.cliqz.com
  hpn-collector.cliqz.com
  hpn-proxy1.cliqz.com
  hpn-proxy2.cliqz.com
  hpn-proxy3.cliqz.com
  hpn-proxy4.cliqz.com
  hpn-sign.cliqz.com
  jp.cliqz.com
  logging.cliqz.com
  mozilla-ucrawl.cliqz.com
  mozsocial.cliqz.com
  newbeta.cliqz.com
  newscat.cliqz.com
  offers-api.cliqz.com
  p2p-pusher.cliqz.com
  p2p-signaling.cliqz.com
  hpn-proxy-04479afc5a8a4cfeb9eb0002e2ca11ca.proxy.cliqz.com
  hpn-proxy-078c54b1e3764c718dcec6d4a64d94e7.proxy.cliqz.com
  hpn-proxy-079f5124a1a2493d86baaf87c1250c24.proxy.cliqz.com
  hpn-proxy-07cd5cb69a6145148b7ecb997e7574f5.proxy.cliqz.com
  hpn-proxy-09d8f184c4ce4ebcaf1e2f3e7db5b239.proxy.cliqz.com
  hpn-proxy-0ab512b3e2ba48e99f963081328c24ab.proxy.cliqz.com
  hpn-proxy-1504919a0f3a4faa87465943700bcf45.proxy.cliqz.com
  hpn-proxy-1ebea398ff764aa7a16f799f4ce8b91d.proxy.cliqz.com
  hpn-proxy-1f659f8c6c16429e9e9f4beb0fb55d07.proxy.cliqz.com
  hpn-proxy-1fd767742bf54421aa4b51a24742a835.proxy.cliqz.com
  hpn-proxy-23a2d333e41e430089ddb0f77105468d.proxy.cliqz.com
  hpn-proxy-255898401e404f529fede661a6952d4c.proxy.cliqz.com
  hpn-proxy-33227b8ab360475aa7971cc083a0f13d.proxy.cliqz.com
  hpn-proxy-3482e591a87c450494e029df5971d476.proxy.cliqz.com
  hpn-proxy-34c97e8be6aa4cf28c5307e5fa0aab4c.proxy.cliqz.com
  hpn-proxy-3acafa1727134597acf01e9c9a18ce2c.proxy.cliqz.com
  hpn-proxy-3dbbeba89f954a2aa02ce9c221977f98.proxy.cliqz.com
  hpn-proxy-43a8f797cc5b49c8ae7545f3b47b9482.proxy.cliqz.com
  hpn-proxy-4847827b825044bebd4d292c55b198e1.proxy.cliqz.com
  hpn-proxy-4e52b66c736f4f929e2e314b5c92ed18.proxy.cliqz.com
  hpn-proxy-50c1402f7f1547318e1a0b0d45009b8f.proxy.cliqz.com
  hpn-proxy-50c2113b202141aca224c4a4562a46d5.proxy.cliqz.com
  hpn-proxy-538c4d78959e45d7b5595a2d0e145592.proxy.cliqz.com
  hpn-proxy-58d187cbc5fe4d8a82cb5008eb8dcc13.proxy.cliqz.com
  hpn-proxy-5c06251d956b4144b3b6515b4c8c5784.proxy.cliqz.com
  hpn-proxy-624a2ea2830d4c108b4340982a060e41.proxy.cliqz.com
  hpn-proxy-63a4e84af688468c89b0a7f321bb35e3.proxy.cliqz.com
  hpn-proxy-67b86c66f82c42a18c9b51c39e7728a6.proxy.cliqz.com
  hpn-proxy-6e6485f59a484df49726293b04433065.proxy.cliqz.com
  hpn-proxy-755e535edb0c48638b8ccf1ff1e51c69.proxy.cliqz.com
  hpn-proxy-768057492ec94f1788d6af55c4604ebf.proxy.cliqz.com
  hpn-proxy-7cab5c943d4741fca56f4963dc5cfd61.proxy.cliqz.com
  hpn-proxy-8075680b6f2644f0b9c14892edc9c84b.proxy.cliqz.com
  hpn-proxy-811fc51dab354e669000b748cfc0d0ac.proxy.cliqz.com
  hpn-proxy-818d98827a8c4df7ab1e659dca292e6f.proxy.cliqz.com
  hpn-proxy-82337ab4ff77488e9268994ff664e622.proxy.cliqz.com
  hpn-proxy-8723b68878d14feb97fd668727e38b31.proxy.cliqz.com
  hpn-proxy-89ce5e3512f446fcb696f4fb185197b6.proxy.cliqz.com
  hpn-proxy-89d097ccb40c4cc3b4b7531c6ca4f55c.proxy.cliqz.com
  hpn-proxy-8ba59afabc00425b909d8ab87754a340.proxy.cliqz.com
  hpn-proxy-8d8078e4e8964ed1b3dc773190f3e0fc.proxy.cliqz.com
  hpn-proxy-8ea7d274fd374aeca4e7b39d5ca7a8f2.proxy.cliqz.com
  hpn-proxy-9f8b0573125a4cd9a2eb2d0d268da818.proxy.cliqz.com
  hpn-proxy-a0791193d0434404946c07f55a4e127b.proxy.cliqz.com
  hpn-proxy-a8ff01ca40034d99b908a3281b2b651f.proxy.cliqz.com
  hpn-proxy-abc6eb0d25564956a74d0e272afd1508.proxy.cliqz.com
  hpn-proxy-af65f148742846f1ad8950d7cae28ba0.proxy.cliqz.com
  hpn-proxy-b0d4e9b3979a4b5dbaea53b1717636d1.proxy.cliqz.com
  hpn-proxy-b5a53a9c53a24e66b97191659facca60.proxy.cliqz.com
  hpn-proxy-b5db41bbb8384178bc5fb2e0858ad417.proxy.cliqz.com
  hpn-proxy-b6698bf500154623996ccf15d90be917.proxy.cliqz.com
  hpn-proxy-b7085bab2d2749b6b6c2ba800c4de262.proxy.cliqz.com
  hpn-proxy-bbb585de503149ea9289968c76383314.proxy.cliqz.com
  hpn-proxy-c12cbbe0f775495ba6f8a84255e33086.proxy.cliqz.com
  hpn-proxy-cc630d54e70e43d588183c66c10a586c.proxy.cliqz.com
  hpn-proxy-ce0618aa70474e7b9b5685d927610f02.proxy.cliqz.com
  hpn-proxy-cec5142343a9455b90b6ea7d7b8c65d4.proxy.cliqz.com
  hpn-proxy-d143c4a0257e4017926be7ff6578eb8b.proxy.cliqz.com
  hpn-proxy-e02ac35ac5414e8b8cd08dc45c28f82c.proxy.cliqz.com
  hpn-proxy-e1759ecb1e5b4d7d8f34b2e739a68a69.proxy.cliqz.com
  hpn-proxy-e4d36bbb44864804862eaa988aa54df2.proxy.cliqz.com
  hpn-proxy-e53b01d7aea2469793bf9a1593034b7b.proxy.cliqz.com
  hpn-proxy-e562884a51894dfa9ef770ade8483fba.proxy.cliqz.com
  hpn-proxy-e7120049e5824a328c034b5f68cbee1a.proxy.cliqz.com
  hpn-proxy-ee5fa1a3a4f24f5d97bca6ad6bb06477.proxy.cliqz.com
  hpn-proxy-f19e7af854354326917bbaa81e912003.proxy.cliqz.com
  hpn-proxy-f237d1a7e9a74cbba375490be4777f8a.proxy.cliqz.com
  hpn-proxy-f587a23546ca40e98b264569c84cea32.proxy.cliqz.com
  hpn-proxy-f7d85d2a8bc84bbabcc95a80908b3ed8.proxy.cliqz.com
  hpn-proxy-fbbb683ca17f4ef188a2b14236fb4add.proxy.cliqz.com
  redirect.cliqz.com
  reports.cliqz.com
  repository.cliqz.com
  safe-browsing.cliqz.com
  safe-browsing-proxy-network.cliqz.com
  safe-browsing-quorum.cliqz.com
  secure.cliqz.com
  static.cliqz.com
  stats.cliqz.com
  hpn.test.cliqz.com
  site1.test.cliqz.com
  site2.test.cliqz.com
  site3.test.cliqz.com
  site4.test.cliqz.com
  site5.test.cliqz.com
  tracker.cliqz.com
  updatecheck.cliqz.com
  w5cdn.cliqz.com
  webbeta.cliqz.com

  # Block LogRocket from recording the screen during a website session
  i.logrocket.com
'

# User defined blacklist
# Only exact strings, no regex supported
readonly USER_BLACKLIST='
'

# hosts_blacklist DOMAINS
# Only exact strings, no regex supported
readonly HOSTS_BLACKLIST="
  ${JUMPSCARE_BLACKLIST}
  ${ADVERTISEMENT_BLACKLIST}
  ${BAD_SITE_BLACKLIST}
  ${TRACKING_BLACKLIST}
  ${USER_BLACKLIST}
"

# The base ipsets
# Provides a basic amount of protection without breaking sites, or breaking
# only a minimal amount of sites
readonly BASE_IPSET_SOURCES='
  https://www.projecthoneypot.org/list_of_ips.php?t=d&rss=1
  https://blocklist.greensnow.co/greensnow.txt
  https://lists.blocklist.de/lists/all.txt
  https://www.spamhaus.org/drop/drop.lasso
  https://check.torproject.org/cgi-bin/TorBulkExitList.py?ip=1.1.1.1
  https://www.maxmind.com/en/proxy-detection-sample-list

  # Other ipset sources
  #
  # http://danger.rulez.sk/projects/bruteforceblocker/blist.php
  #
  # HTTP Sources
  # http://cinsscore.com/list/ci-badguys.txt
'

# The sources that will be parsed into the ipset.
# By default only the sources in the ${base_sources} list
# are included, additional sources can be included by
# appending them onto lines following the base-sources line.
# Destinations and duplicate entries do not matter, as they will
# be sanitized and duplicates will be stripped out.
readonly IPSET_SOURCES="

  ${BASE_IPSET_SOURCES}

"
readonly IPSET_WHITELIST='
  127.0.0.1
  0.0.0.0
  255.255.255.255
'

# BLACKLIST IPS
# Only exact strings, no regex supported
# CIDR supported
readonly IPSET_BLACKLIST='
  1.1.1.1

  # Blacklists admiral
  104.198.107.72
'

__temp_files="" # Leave blank
__pids="" # Leave blank
__blocklist="" # Leave blank

main "$@" || {
  cancel_sudoloop 1
}

cancel_sudoloop 0
# vim: set syntax=sh tabstop=2 softtabstop=2 shiftwidth=2 shiftround expandtab:
